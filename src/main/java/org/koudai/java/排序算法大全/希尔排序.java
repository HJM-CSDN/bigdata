package org.koudai.java.排序算法大全;

import java.util.Arrays;

/**
 * @description 希尔排序
 * @Auther: 韩金铭 1329674322@qq.com
 * @Date: 2016/10/9
 */

/**
 * 基本思想:
 * 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。
 * 所有距离为d1的倍数的记录放在同一个组中。
 * 先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，
 * 直至所取的增量=1，即所有记录放在同一组中进行直接插入排序为止。
 * 该方法实质上是一种分组插入方法
 * 比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，
 * 则进行一次比较就可能消除多个元素交换。
 * D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。
 * 算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.
 * 对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。
 * 当增量减到1时，整个要排序的数被分成一组，排序完成。
 * 一般的初次取序列的一半为增量，以后每次减半，直到增量为1。
 */
/*
 * 希尔排序的时间复杂度与增量序列的选取有关，
 * 例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^(3/2))，
 * 希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，
 * 因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。
 */

/*
 * 希尔排序是非稳定排序算法
 * 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，
 * 但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，
 * 最后其稳定性就会被打乱，所以shell排序是不稳定的。
 */
public class 希尔排序 {
    public static void main(String[] args) {
        int[] array = {1,5,2,3,6,2,34,5,345,543,2,2,1,35,64,2,2,0,-98};
        shellSort(array);
        String s = Arrays.toString(array);
        System.out.println(s);
    }
    public static void shellSort(int[] array){

    }
}

