1.JVM内存管理机制
    JVM内存结构主要有三大块：堆内存、方法区和栈。
    内存空间划为堆、JVM方法栈、方法区、本地方法栈、PC寄存器

    堆：用户存储对象实例及数组

    方法栈：通过-Xss指定其大小。为线程私有，其在内存分配上十分高效。

    方法区：要加载的类的信息（名称、修饰符等）、类中的静态变量、类中
            定义为final类型的常量、类中的Field信息、类中的方法信息。

    本地方法栈：用于支持native方法的执行，存储了每个native方法调用的状态

    PC寄存器：占用的可能为CPU寄存器或操作系统内存。

2.Java中堆栈区别
    Java把内存分为两种：一种是栈内存、一种是堆内存


3.Java（堆）内存泄露和内存溢出
    内存泄露：分配出去的内存回收不了。
    内存溢出：系统内存不够用了。

4、Java的类加载机制
    1、装载：找到二进制字节码并加载到JVM中。
    2、链接：链接过程负责对二进制字节码的格式进行校验、
             初始化装载类中的静态变量及解析类中调用的接口、类；
    3、初始化：执行静态类中的静态初始化代码、构造器代码以及静态属性的初始化。

5.内存回收GC
    收集器：引用计数器、跟踪收集器

    引用计数器：不适合Java这种面向对象的会形成复杂引用关系的语言

    跟踪收集器的算法：复制、标记-清除、标记-压缩

        复制：当要回收的空间中存活对象较少时，复制算法会比较高效，
              其带来的成本是要增加一块空的内存空间及进行对象的移动。

        标记-清除：空间中存活对象较多时比较高效，但是直接回收会造成内存碎片。

        标记-压缩：在标记-清除的基础上还必须进行对象移动，成本较高，
                   但是不会产生内存碎片。


jvm运行时数据区域
	方法区和堆   （由所有线程共享的数据区）
	虚拟机栈、本地方法栈、程序计数器   （线程隔离的数据区）



Fifo schedular :默认，先进先出的原则

Capacity schedular :计算能力调度器，选择占用最小、优先级高的先执行，依此类推。

Fair schedular:公平调度，所有的job具有相同的资源。

